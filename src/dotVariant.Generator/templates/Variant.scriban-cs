{{~
# Copyright Miro Knejp 2021.
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE.txt or copy at https://www.boost.org/LICENSE_1_0.txt)
~}}
{{~ ##
Global input variables are fed from C# RenderInfo members:
- Language : LanguageInfo
- Options : OptionsInfo
- Params : ParamInfo[]
- Runtime : RuntimeInfo
- Variant : VariantInfo
## ~}}
{{~ include "globals" ~}}
{{~ if Language.Version >= 800 ~}}
#nullable {{ Language.Nullable }}
{{~ end ~}}
{{~ if Variant.Namespace ~}}
namespace {{ Variant.Namespace }}
{
{{~ end ~}}
    [global::System.Diagnostics.DebuggerTypeProxy(typeof(_VariantTypeProxy))]
    [global::System.Diagnostics.DebuggerDisplay("{_variant.AsObject}", Type = "{_variant.TypeString,nq}")]
    partial {{ Variant.Keyword }} {{ Variant.Name }}
        : global::System.IEquatable<{{ Variant.Name }}>
        {{~ if needs_dispose ~}}
        , global::System.IDisposable
        {{~ end ~}}
    {
        private readonly {{ storage_type }} _variant;

        {{~ ## VARIANT CONSTRUCTORS ## ~}}
        {{~ for $p in Params ~}}
        /// <summary>
        /// Create a {{ Variant.Name }} with a value of type <see cref="{{ cref $p.Name }}"/>.
        /// </summary>
        /// <param name="{{ $p.Hint }}">The value to initlaize the variant with.</param>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ Variant.Name }}({{ value_type $p }} {{ $p.Hint }})
            => _variant = new {{ storage_type }}({{ $p.Hint }});
        {{~ end ~}}

        {{~ ## IMPLICIT CONVERSIONS ## ~}}
        {{~ for $p in Params ~}}
        {{~ if $p.EmitImplicitCast ~}}
        /// <summary>
        /// Create a {{ Variant.Name }} with a value of type <see cref="{{ cref $p.Name }}"/>.
        /// </summary>
        /// <param name="{{ $p.Hint }}">The value to initlaize the variant with.</param>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public static implicit operator {{ Variant.Name }}({{ value_type $p }} {{ $p.Hint }})
            => new {{ Variant.Name }}({{ $p.Hint }});
        {{~ end ~}}
        {{~ end ~}}

        {{~ ## STATIC CREATE FACTORIES ## ~}}
        {{~ for $p in Params ~}}
        /// <summary>
        /// Create a {{ Variant.Name }} with a value of type <see cref="{{ cref $p.Name }}"/>.
        /// </summary>
        /// <param name="{{ $p.Hint }}">The value to initlaize the variant with.</param>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public static {{ Variant.Name }} Create({{ value_type $p }} {{ $p.Hint }})
            => new {{ Variant.Name }}({{ $p.Hint }});
        {{~ end ~}}

        {{~ ## DISPOSE ## ~}}
        {{~ if needs_dispose && !Variant.UserDefined.Dispose }}
        /// <inheritdoc/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public void Dispose()
        {
            _variant.Dispose();
        }
        {{~ end ~}}

        {{~ ## VARIANT IsEmpty ## ~}}
        /// <inheritdoc cref="{{ cref storage_type }}.IsEmpty"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}bool IsEmpty
            => _variant.IsEmpty;

        {{~ ## VARIANT Equals ## ~}}
        /// <inheritdoc/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}override bool Equals(object{{ global_nullable }} other)
            => other is {{ Variant.Name }} v && Equals(v);

        /// <inheritdoc/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}bool Equals({{ value_type Variant }} other)
            => {{ if Variant.IsClass; "!(other is null) && "; end }}_variant.Equals(other._variant);

        [global::System.Diagnostics.DebuggerNonUserCode]
        public static bool operator ==({{ param_modifiers; value_type Variant }} lhs, {{ param_modifiers; value_type Variant }} rhs)
        => {{ coalesce Variant "lhs" ".Equals(rhs)" "(rhs is null)" }};

        [global::System.Diagnostics.DebuggerNonUserCode]
        public static bool operator !=({{ param_modifiers; value_type Variant }} lhs, {{ param_modifiers; value_type Variant }} rhs)
        => !(lhs == rhs);

        {{~ ## VARIANT GetHashCode ## ~}}
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}override int GetHashCode()
            => _variant.GetHashCode();

        {{~ ## VARIANT ToString ## ~}}
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}override string ToString()
            => _variant.ToString();

        {{~ for $p in Params ~}}
        {{~ ## VARIANT TryMatch ## ~}}
        /// <inheritdoc cref="{{ cref storage_type }}.TryMatch(out {{ cref (outref_type $p) }})"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}bool TryMatch({{ annotate_NotNullWhen $p }}out {{ outref_type $p }} {{ $p.Hint }})
            => _variant.TryMatch(out {{ $p.Hint }});

        /// <inheritdoc cref="{{ cref storage_type }}.TryMatch(out {{ cref (action_type $p) }})"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}bool TryMatch({{ action_type $p }} {{ $p.Hint }})
            => _variant.TryMatch({{ $p.Hint }});

        {{~ ## VARIANT Match ## ~}}
        /// <inheritdoc cref="{{ cref storage_type }}.Match(out {{ cref (outref_type $p) }})"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}void Match({{ annotate_NotNull $p }}out {{ outref_type $p }} {{ $p.Hint }})
            => _variant.Match(out {{ $p.Hint }});

        /// <inheritdoc cref="{{ cref storage_type }}.Match({{ cref (action_type $p) }})"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}void Match({{ action_type $p }} {{ $p.Hint }})
            => _variant.Match({{ $p.Hint }});

        /// <inheritdoc cref="{{ cref storage_type }}.Match({{ cref (action_type $p) }}, global::System.Action)"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}void Match({{ action_type $p }} {{ $p.Hint }}, global::System.Action _)
            => _variant.Match({{ $p.Hint }}, _);

        /// <inheritdoc cref="{{ cref storage_type }}.Match{TResult}({{ cref (func_type $p) }})"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}TResult Match<TResult>({{ func_type $p }} {{ $p.Hint }})
            => _variant.Match({{ $p.Hint }});

        /// <inheritdoc cref="{{ cref storage_type }}.Match{TResult}({{ cref (func_type $p) }}, TResult)"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}TResult Match<TResult>({{ func_type $p }} {{ $p.Hint }}, TResult _)
            => _variant.Match({{ $p.Hint }}, _);

        /// <inheritdoc cref="{{ cref storage_type }}.Match{TResult}({{ cref (func_type $p) }}, global::System.Func{TResult})"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}TResult Match<TResult>({{ func_type $p }} {{ $p.Hint }}, global::System.Func<TResult> _)
            => _variant.Match({{ $p.Hint }}, _);

        {{~ end ~}}

        {{~ ## VARIANT Visit ## ~}}
        /// <inheritdoc cref="{{ cref storage_type }}.Visit({{ cref action_types }})"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}void Visit({{ action_params }})
            => _variant.Visit({{ forward_params }});

        /// <inheritdoc cref="{{ cref storage_type }}.Visit({{ cref action_types }}, global::System.Action)"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}void Visit({{ action_params }}, global::System.Action _)
            => _variant.Visit({{ forward_params }}, _);

        /// <inheritdoc cref="{{ cref storage_type }}.Visit{TResult}({{ cref func_types }})"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}TResult Visit<TResult>({{ func_params }})
            => _variant.Visit({{ forward_params }});

        /// <inheritdoc cref="{{ cref storage_type }}.Visit{TResult}({{ cref func_types }}, global::System.Func{TResult})"/>
        [global::System.Diagnostics.DebuggerNonUserCode]
        public {{ method_modifiers }}TResult Visit<TResult>({{ func_params }}, global::System.Func<TResult> _)
            => _variant.Visit({{ forward_params }}, _);

        private sealed class _VariantTypeProxy
        {
            public object{{ global_nullable }} Value { get; }
            public _VariantTypeProxy({{ Variant.Name }} v)
            {
                Value = v._variant.AsObject;
                {{~ # Force a reference to the VariantOf function so the user doesn't get IDE0051 "Private member 'VariantOf' is unused." ~}}
                VariantOf({{ Params | array.each @(do; ret forgive $0 "default"; end) | array.join ", " }});
            }
        }

        {{~ ## INTERNAL ACCESS ## ~}}
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        [global::System.Diagnostics.DebuggerNonUserCode]
        public static explicit operator {{ discriminator }}({{ Variant.Name }} v)
            => ({{ discriminator }})v._variant;
        {{~ for $p in Params ~}}
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        [global::System.Diagnostics.DebuggerNonUserCode]
        public static explicit operator {{ accessor $p.Index (value_type $p) }}({{ Variant.Name }} v)
            => ({{ accessor $p.Index (value_type $p) }})v._variant;
        {{~ end ~}}
    }
{{~ if Variant.Namespace ~}}
}
{{~ end ~}}

{{ include "Union" }}

{{~
if Variant.ExtensionsAccessibility
    include "IEnumerable"
    if Runtime.HasSystemReactiveLinq
        include "IObservable"
    end
end
~}}
