{{~
# Copyright Miro Knejp 2021.
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE.txt or copy at https://www.boost.org/LICENSE_1_0.txt)
~}}
{{~ ##
Global input variables are fed from C# RenderInfo members:
- Language : LanguageInfo
- Options : OptionsInfo
- Params : ParamInfo[]
- Runtime : RuntimeInfo
- Variant : VariantInfo
## ~}}
{{~
emit_nullability = Language.Version >= 800 && Language.Nullable == "enable"
readonly emit_nullability

# The type to use for variables and function parameters
# Works with both "Params" and "Variant"
func value_type(type, name = null)
    if (name == null)
        name = type.Type
    end
    if type.IsClass
        ret emit_nullability && type.Nullability == "nullable" ? (name + "?" ): name
    else
        ret name
    end
end
readonly value_type

# The type to use for out or ref parameters
# Works with both "Params" and "Variant"
func outref_type(type, name = null)
    if (name == null)
        name = type.Type
    end
    if type.IsClass
        ret emit_nullability ? (name + "?") : name
    else
        ret name
    end
end
readonly outref_type

func func_type(param, result = "TResult")
    ret "global::System.Func<" + (value_type param) + ", " + result + ">"
end
readonly func_type

func action_type(param)
    ret "global::System.Action<" + (value_type param) + ">"
end
readonly action_type

# Conditionally append forgive-operator to an expression
# Works with both "Params" and "Variant"
func forgive(type, expression)
    if type.IsClass
        ret emit_nullability && type.Nullability == "nonnull" ? (expression + "!") : expression
    else
        ret expression
    end
end
readonly forgive

# Conditionally apply a null-caolescing member access with trailing null-expression after the ??
# Works with both "Params" and "Variant"
func coalesce(type, expression, sub_expression, null_expression = null)
    if type.Nullability == "nullable"
        ret expression + "?" + sub_expression + (null_expression != null ? (" ?? " + null_expression) : "")
    else
        ret expression + sub_expression
    end
end
readonly coalesce

func coalesce_ToString(type, expression)
    if type.Nullability == "nonnull" && type.ToStringNullability == "nonnull"
        ret expression + ".ToString()"
    else
        ret expression + (type.Nullability == "nullable" ? "?" : "") + ".ToString() ?? \"null\""
    end
end
readonly coalesce_ToString

func param_hint(param)
    ret param.Hint
end
readonly param_hint

func annotate_NotNullWhen(param)
    if param.IsClass && emit_nullability
        ret param.Nullability == "nonnull" ? "[global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] " : ""
    else
        ret ""
    end
end
readonly annotate_NotNullWhen

func annotate_NotNull(param)
    if param.IsClass && emit_nullability
        ret param.Nullability == "nonnull" ? "[global::System.Diagnostics.CodeAnalysis.NotNull] " : ""
    else
        ret ""
    end
end
readonly annotate_NotNull

func throw_mismatch_error(expected, actual, type = "")
    ret "global::dotVariant.GeneratorSupport.Errors.ThrowMismatchError" + (type == "" ? "" : "<" + type + ">") + "(" + ([string.literal Variant.DiagType, string.literal expected, actual] | array.join ", ") + ")"
end
readonly throw_mismatch_error

func throw_internal_error(type = "")
    ret "global::dotVariant.GeneratorSupport.Errors.ThrowInternalError" + (type == "" ? "" : "<" + type + ">") + "(" + (string.literal Variant.DiagType) + ")"
end
readonly throw_internal_error

func throw_empty_error(type = "")
    ret "global::dotVariant.GeneratorSupport.Errors.ThrowEmptyError" + (type == "" ? "" : "<" + type + ">") + "(" + (string.literal Variant.DiagType) + ")"
end
readonly throw_empty_error_error

func make_mismatch_error(expected, actual)
    ret "global::dotVariant.GeneratorSupport.Errors.MakeMismatchError(" + ([string.literal Variant.DiagType, string.literal expected, actual] | array.join ", ") + ")"
end
readonly make_mismatch_error

func make_internal_error()
    ret "global::dotVariant.GeneratorSupport.Errors.MakeInternalError(" + (string.literal Variant.DiagType) + ")"
end
readonly make_internal_error

func make_empty_error()
    ret "global::dotVariant.GeneratorSupport.Errors.MakeEmptyError(" + (string.literal Variant.DiagType) + ")"
end
readonly make_empty_error_error

storage_type = "__VariantImpl"
readonly storage_type

func get_value(param, expression = "_variant")
    ret "((global::dotVariant.GeneratorSupport.Accessor_" + param.Index + "<" + value_type param + ">)" + expression + ").Value"
end
readonly get_value

func get_n(expression = "_variant")
    ret "((int)(global::dotVariant.GeneratorSupport.Discriminator)" + expression + ")"
end
readonly get_n

func cref(name)
    ret name | string.replace "<" "{" | string.replace ">" "}"
end
readonly cref

func accessor(index, type)
    ret "global::dotVariant.GeneratorSupport.Accessor_" + index + "<" + type + ">"
end
readonly accessor

func_types = Params | array.each @(do; ret func_type $0; end) | array.join ", "
func_params = Params | array.each @(do; ret (func_type $0) + " " + $0.Identifier; end) | array.join ", "
action_types = Params | array.each @(do; ret action_type $0; end) | array.join ", "
action_params = Params | array.each @(do; ret (action_type $0) + " " + $0.Identifier; end) | array.join ", "
method_modifiers = !Variant.IsClass && Language.Version >= 800 ? "readonly " : ""
param_modifiers = !Variant.IsClass && Variant.IsReadonly && Language.Version >= 702 ? "in " : ""
global_nullable = emit_nullability ? "?" : ""
global_forgive = emit_nullability ? "!" : ""
needs_dispose = (Params | array.filter @(do; ret $0.IsDisposable; end) | array.size) > 0
forward_params = Params | array.each @(do; ret $0.Identifier; end) | array.join ", "
discriminator = "global::dotVariant.GeneratorSupport.Discriminator"

readonly func_types
readonly func_params
readonly action_types
readonly action_params
readonly method_modifiers
readonly param_modifiers
readonly global_nullable
readonly global_forgive
readonly needs_dispose
readonly forward_params
readonly discriminator
~}}
