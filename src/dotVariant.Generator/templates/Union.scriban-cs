{{~
# Copyright Miro Knejp 2021.
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE.txt or copy at https://www.boost.org/LICENSE_1_0.txt)
~}}
{{~ ##
Variant tries to use as little space as possible by using an Explicit layout
for its possible option types. Because Variant is a sum type there can only
ever be a single "active" field, i.e. holding real data.

This means we can use explicit layout and overlap those types onto the same
area of memory. There is only one restriction that we must adhere to:

    An unmanaged field and a reference field cannot occupiy the same space.

To ensure this the CLR switches the layout of structs containing reference
fields from the default "Sequential" to "Auto" and seems to separate all
reference fields from unmanaged fields. Let's look at this with a concrete
example:

struct A { public IntPtr i; public IntPtr j; }
struct B { public object o; public IntPtr x; }

Have a look at the memory layout of

[StructLayout(LayoutKind.Explicit)]
class Variant { [FieldOffset(0)] public A a; [FieldOffset(0)] public B b; }

+--------+-----------------+
| offset | Variant         |
+--------+-----------------+
|        | +-----+ +-----+ |
|      0 | | A.i | | B.o | | <- ERROR: TypeLoadException
|        | +-----+ +-----+ |
|      8 | | A.j | | B.x | |
|        | +-----+ +-----+ |
+--------+-----------------+

The line marked above shows how an object reference (B.o) is now sharing
space with an unmanaged type (A.i). Trying to load this type will trigger a
TypeLoadException saying Variant "contains an object field at offset 0
that is incorrectly aligned or overlapped by a non-object field".

The way we fix this is by wrapping A in a new struct and adding an object reference
to it:

struct WrapA { public A a; public object o; }

[StructLayout(LayoutKind.Explicit)]
class Variant { [FieldOffset(0)] private WrapA a; [FieldOffset(0)] private B b; }

Leading to this layout:

+--------+---------------------------+
| offset | Variant                   |
+--------+---------------------------+
|        | +---------------+ +-----+ |
|      0 | | WrapA.o       | | B.o | | <- OK
|        | +---------------+ |     | |
|        | | +-----------+ | +-----+ |
|      8 | | | WrapA.a.i | | | B.x | |
|        | | +-----------+ | +-----+ |
|     16 | | | WrapA.a.j | |         |
|        | | +-----------+ |         |
|        | +---------------+         |
+------------------------------------+

This layout no longer causes exceptions and can be loaded but at the cost
of extra memory consumption and unused "dummy" fields.

We still have one issue though: where do we put the discriminator (the
integer telling us which value is "active" in the Variant)? It needs to
always be at the same memory location regardless of the currently active
type. We also cannot force it to offset 0 because that's where the managed
types will go. The solution here is an extra level of indirection:

    Put all the WrapX types inside a new struct with the explicit layout
    and leave the discriminator integer outside:

[StructLayout(LayoutKind.Explicit)]
struct Values
{
    [FieldOffset(0)] public WrapA a;
    [FieldOffset(0)] public WrapB b;
    ...
    [FieldOffset(0)] public WrapN n;
}

class Variant { private int discriminator; private Values values; }

+--------+-------------------------------------+
| offset | Variant                             |
+--------+-------------------------------------+
|      0 | discriminator                       |
+--------+-------------------------------------+
|        | values                              |
|        | +---------------------------------+ |
|        | | +---------------+ +-----------+ | |
|      8 | | | WrapA.o       | | WrapB.b.o | | |
|        | | +---------------+ |           | | |
|        | | | +-----------+ | +-----------+ | |
|     16 | | | | WrapA.a.i | | | WrapB.b.x | | |
|        | | | +-----------+ | +-----------+ | |
|     24 | | | | WrapA.a.j | |               | |
|        | | | +-----------+ |               | |
|        | | +---------------+               | |
|        | +---------------------------------+ |
+--------+-------------------------------------+

While this results in some overhead, as the Variant's size is
the sum of max(object fields) + max(non-object fields) for all
possible values it can hold, it allows for the elision of boxing
for value types and still consumes *much* less memory than if
it had to store all values side-by-side.
## ~}}
{{~
func $storage(param)
    ret "_x._" + param.Index + ".Value"
end
~}}
{{~ ## STORAGE WRAPPER ## ~}}
{{~ if Variant.Namespace ~}}
namespace {{ Variant.Namespace }}
{
{{~ end ~}}
    partial {{ Variant.Keyword }} {{ Variant.Name }}
    {
        [global::System.Diagnostics.DebuggerNonUserCode]
        [global::System.Diagnostics.DebuggerDisplay("{AsObject}", Type = "{TypeString,nq}")]
        private readonly struct __VariantImpl
        {{~ if needs_dispose ~}}
            : global::System.IDisposable
        {{~ end ~}}
        {
            {{~ ## UNION TYPE ## ~}}
            [global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Explicit)]
            private readonly struct Union
            {
                {{~ ## UNION MEMBERS ## ~}}
                {{~ for $p in Params ~}}
                [global::System.Runtime.InteropServices.FieldOffset(0)]
                public readonly Value_{{ $p.Index }} _{{ $p.Index }};
                {{~ end ~}}

                {{~ ## UNION CONSTRUCTORS ## ~}}
                {{~ for $p in Params ~}}
                public Union({{ value_type $p }} value)
                {
                    {{~ for $other in Params | array.remove_at ($p.Index - 1) ~}}
                    _{{ $other.Index }} = default;
                    {{~ end ~}}
                    _{{ $p.Index }} = new Value_{{ $p.Index }}(value);
                }
                {{~ end ~}}
            }

            {{~ ## PER-TYPE WRAPPERS WITH PADDING ## ~}}
            {{~ for $p in Params ~}}
            [global::System.Diagnostics.DebuggerNonUserCode]
            private readonly struct Value_{{ $p.Index }}
            {
                public readonly {{ value_type $p }} Value;
                {{~ for $dummy in (1..$p.ObjectPadding) limit:$p.ObjectPadding ~}}
                public readonly object _dummy{{ $dummy }};
                {{~ end ~}}

                public Value_{{ $p.Index }}({{ value_type $p }} value)
                {
                    {{~ for $dummy in (1..$p.ObjectPadding) limit:$p.ObjectPadding ~}}
                    _dummy{{ $dummy }} = null{{ global_forgive }};
                    {{~ end ~}}
                    Value = value;
                }
            }
            {{~ end ~}}

            private readonly Union _x;
            private readonly byte _n;

            {{~ ## STORAGE CONSTRUCTORS ## ~}}
            {{~ for $p in Params ~}}
            public __VariantImpl({{ value_type $p }} {{ $p.Hint }})
            {
                _n = {{ $p.Index }};
                _x = new Union({{ $p.Hint }});
            }
            {{~ end ~}}

            {{~ if needs_dispose ~}}
            public void Dispose()
            {
                switch (_n)
                {
                    case 0:
                        break;
                    {{~ for $p in Params ~}}
                    case {{ $p.Index }}:
                        {{~ if $p.IsDisposable ~}}
                        {{ coalesce $p ($storage $p) ".Dispose()" }};
                        {{~ end ~}}
                        break;
                    {{~ end ~}}
                    default:
                        {{ throw_internal_error }};
                        break;
                }
            }
            {{~ end ~}}

            {{~ ## INTERNAL ACCESS ## ~}}
            public static explicit operator {{ discriminator }}(in __VariantImpl v)
                => ({{ discriminator }})v._n;
            {{~ for $p in Params ~}}
            public static explicit operator {{ accessor $p.Index (value_type $p) }}(in __VariantImpl v)
                => new {{ accessor $p.Index (value_type $p) }}(v._x._{{ $p.Index }}.Value);
            {{~ end ~}}

            /// <summary>
            /// <see langword="true"/> if {{ Variant.Name }} was constructed without a value.
            /// </summary>
            {{~ if !Variant.IsClass ~}}
            /// <remarks>
            /// Because {{ Variant.Name }} is a value type, its default constructor cannot be disabled.
            /// A default-constructed {{ Variant.Name }} will always have a <see cref="IsEmpty"/> value of <see langword"true"/>
            /// and never satisfy any matching attempts except for the wildcard <c>_</c> parameter.
            /// </remarks>
            {{~ end ~}}
            public bool IsEmpty => _n == 0;

            /// <summary>
            /// The string representation of the stored value's type.
            /// </summary>
            public string TypeString
            {
                get
                {
                    switch (_n)
                    {
                        case 0:
                            return "<empty>";
                        {{~ for $p in Params ~}}
                        case {{ $p.Index }}:
                            return "{{ $p.DiagName }}";
                        {{~ end ~}}
                        default:
                            return {{ throw_internal_error "string" }};
                    }
                }
            }

            /// <summary>
            /// The stored value's <see cref="object.ToString()"/> result, or <c>""</c> if empty.
            /// </summary>
            public override string ToString()
            {
                switch (_n)
                {
                    case 0:
                        return "";
                    {{~ for $p in Params ~}}
                    case {{ $p.Index }}:
                        return {{ coalesce_ToString $p ($storage $p) }};
                    {{~ end ~}}
                    default:
                        return {{ throw_internal_error "string" }};
                }
            }

            /// <summary>
            /// The stored value cast to type <see cref="object"/>.
            /// </summary>
            public object{{ global_nullable }} AsObject
            {
                get
                {
                    switch (_n)
                    {
                        case 0:
                            return null;
                        {{~ for $p in Params ~}}
                        case {{ $p.Index }}:
                            return {{ $storage $p }};
                        {{~ end ~}}
                        default:
                            return {{ throw_internal_error "object" + global_nullable }};
                    }
                }
            }

            public bool Equals(in __VariantImpl other)
            {
                if (_n != other._n)
                {
                    return false;
                }
                switch (_n)
                {
                    case 0:
                        return true;
                    {{~ for $p in Params ~}}
                    {{~ $i = $p.Index ~}}
                    case {{ $i }}:
                        return global::System.Collections.Generic.EqualityComparer<{{ $p.Name }}>.Default.Equals({{ $storage $p }}, other.{{ $storage $p }});
                    {{~ end ~}}
                    default:
                        return {{ throw_internal_error "bool" }};
                }
            }

            public override int GetHashCode()
            {
                switch (_n)
                {
                    case 0:
                        return 0;
                    {{~ for $p in Params ~}}
                    {{~ $i = $p.Index ~}}
                    case {{ $i }}:
                        {{~ if Runtime.HasHashCode ~}}
                        return global::System.HashCode.Combine({{ $storage $p }});
                        {{~ else ~}}
                        return {{ coalesce $p ($storage $p) ".GetHashCode()" "0"}};
                        {{~ end ~}}
                    {{~ end ~}}
                    default:
                        return {{ throw_internal_error "int" }};
                }
            }

            {{~ for $p in Params ~}}
            {{~ ## UNION TryMatch ## ~}}
            /// <summary>
            /// Retrieve the value stored within {{ Variant.Name }} if it is of type <see cref="{{ cref $p.Name }}"/>.
            /// </summary>
            /// <param name="{{ $p.Hint }}">Receives the stored value if it is of type <see cref="{{ cref $p.Name }}"/>.</param>
            /// <returns><see langword="true"/> if {{ Variant.Name }} contained a value of type <see cref="{{ cref $p.Name }}"/>.</returns>
            public bool TryMatch({{ annotate_NotNullWhen $p }}out {{ outref_type $p }} {{ $p.Hint }})
            {
                {{ $p.Hint }} = _n == {{ $p.Index }} ? {{ $storage $p }} : default;
                return _n == {{ $p.Index }};
            }

            /// <summary>
            /// Invoke a delegate with the value stored within {{ Variant.Name }} if it is of type <see cref="{{ cref $p.Name }}"/>.
            /// </summary>
            /// <param name="{{ $p.Hint }}">The delegate to invoke with the stored value if it is of type <see cref="{{ cref $p.Name }}"/>.</param>
            /// <returns><see langword="true"/> if {{ Variant.Name }} contained a value of type <see cref="{{ cref $p.Name }}"/>.</returns>
            /// <exception cref="global::System.Exception">Any exception thrown from <paramref name="{{ $p.Hint }}"> is rethrown.</exception>
            public bool TryMatch({{ action_type $p }} {{ $p.Hint }})
            {
                if (_n == {{ $p.Index }})
                {
                    {{ $p.Hint }}({{ $storage $p }});
                    return true;
                }
                return false;
            }

            {{~ ## UNION Match ## ~}}
            /// <summary>
            /// Retrieve the value stored within {{ Variant.Name }} if it is of type <see cref="{{ cref $p.Name }}"/>,
            /// otherwise throw <see cref="global::System.InvalidOperationException"/>.
            /// </summary>
            /// <param name="{{ $p.Hint }}">Receives the stored value if it is of type <see cref="{{ cref $p.Name }}"/>.</param>
            /// <exception cref="global::System.InvalidOperationException">{{ Variant.Name }} does not contain a value of type <see cref="{{ cref $p.Name }}"/></exception>
            public void Match({{ annotate_NotNull $p }}out {{ outref_type $p }} {{ $p.Hint }})
            {
                if (_n == {{ $p.Index }})
                {
                    {{ $p.Hint }} = {{ $storage $p }};
                    return;
                }
                throw {{ make_mismatch_error $p.DiagName "{TypeString}" }};
            }

            /// <summary>
            /// Invoke a delegate with the value stored within {{ Variant.Name }} if it is of type <see cref="{{ cref $p.Name }}"/>,
            /// otherwise throw <see cref="global::System.InvalidOperationException"/>.
            /// </summary>
            /// <param name="{{ $p.Hint }}">The delegate to invoke with the stored value if it is of type <see cref="{{ cref $p.Name }}"/>.</param>
            /// <exception cref="global::System.InvalidOperationException">{{ Variant.Name }} does not contain a value of type <see cref="{{ cref $p.Name }}"/></exception>
            /// <exception cref="global::System.Exception">Any exception thrown from <paramref name="{{ $p.Hint }}"> is rethrown.</exception>
            public void Match({{ action_type $p }} {{ $p.Hint }})
            {
                if (_n == {{ $p.Index }})
                {
                    {{ $p.Hint }}({{ $storage $p }});
                    return;
                }
                {{ throw_mismatch_error $p.DiagName "{TypeString}" }};
            }

            /// <summary>
            /// Invoke a delegate with the value stored within {{ Variant.Name }} if it is of type <see cref="{{ cref $p.Name }}"/>,
            /// otherwise invoke an alternative delegate.
            /// </summary>
            /// <param name="{{ $p.Hint }}">The delegate to invoke with the stored value if it is of type <see cref="{{ cref $p.Name }}"/>.</param>
            /// <param name="_">The delegate to invoke if the stored value is of a different type.</param>
            /// <exception cref="global::System.Exception">Any exception thrown from <paramref name="{{ $p.Hint }}"> or <paramref name="_"> is rethrown.</exception>
            public void Match({{ action_type $p }} {{ $p.Hint }}, global::System.Action _)
            {
                if (_n == {{ $p.Index }})
                {
                    {{ $p.Hint }}({{ $storage $p }});
                }
                else
                {
                    _();
                }
            }

            /// <summary>
            /// Invoke a delegate with the value stored within {{ Variant.Name }} if it is of type <see cref="{{ cref $p.Name }}"/> and return the result,
            /// otherwise throw <see cref="global::System.InvalidOperationException"/>.
            /// </summary>
            /// <param name="{{ $p.Hint }}">The delegate to invoke with the stored value if it is of type <see cref="{{ cref $p.Name }}"/>.</param>
            /// <returns>The value returned from invoking <paramref name="{{ $p.Hint }}"/>.</returns>
            /// <exception cref="global::System.InvalidOperationException">{{ Variant.Name }} does not contain a value of type <see cref="{{ cref $p.Name }}"/></exception>
            /// <exception cref="global::System.Exception">Any exception thrown from <paramref name="{{ $p.Hint }}"> is rethrown.</exception>
            public TResult Match<TResult>({{ func_type $p }} {{ $p.Hint }})
            {
                if (_n == {{ $p.Index }})
                {
                    return {{ $p.Hint }}({{ $storage $p }});
                }
                return {{ throw_mismatch_error $p.DiagName "{TypeString}" "TResult" }};
            }

            /// <summary>
            /// Invoke a delegate with the value stored within {{ Variant.Name }} if it is of type <see cref="{{ cref $p.Name }}"/> and return the result,
            /// otherwise return a provided value.
            /// </summary>
            /// <param name="{{ $p.Hint }}">The delegate to invoke with the stored value if it is of type <see cref="{{ cref $p.Name }}"/>.</param>
            /// <param name="_">The value to return if the stored value is of a different type.</param>
            /// <returns>The value returned from invoking <paramref name="{{ $p.Hint }}"/>, or <paramref name="default"/>.</returns>
            /// <exception cref="global::System.Exception">Any exception thrown from <paramref name="{{ $p.Hint }}"> or <paramref name="other"> is rethrown.</exception>
            public TResult Match<TResult>({{ func_type $p }} {{ $p.Hint }}, TResult _)
            {
                return _n == {{ $p.Index }} ? {{ $p.Hint }}({{ $storage $p }}) : _;
            }

            /// <summary>
            /// Invoke a delegate with the value stored within {{ Variant.Name }} if it is of type <see cref="{{ cref $p.Name }}"/> and return the result,
            /// otherwise invoke an alternative delegate and return its result.
            /// </summary>
            /// <param name="{{ $p.Hint }}">The delegate to invoke with the stored value if it is of type <see cref="{{ cref $p.Name }}"/>.</param>
            /// <param name="_">The delegate to invoke if the stored value is of a different type.</param>
            /// <exception cref="global::System.Exception">Any exception thrown from <paramref name="{{ cref $p.Hint }}"> or <paramref name="_"> is rethrown.</exception>
            public TResult Match<TResult>({{ func_type $p }} {{ $p.Hint }}, global::System.Func<TResult> _)
            {
                return _n == {{ $p.Index }} ? {{ $p.Hint }}({{ $storage $p }}) : _();
            }
            {{~ end ~}}

            {{~ ## UNION Visit(Action) ## ~}}
            /// <summary>
            /// Invoke the delegate whose parameter type matches that of type of the value stored within {{ Variant.Name }},
            /// and invoke a special delegate if {{ Variant.Name }} is empty.
            /// </summary>
            {{~ for $p in Params ~}}
            /// <param name="{{ $p.Hint }}">The delegate to invoke if the stored value is of type <see cref="{{ cref $p.Name }}"/>.</param>
            {{~ end ~}}
            /// <param name="_">The delegate to invoke if {{ Variant.Name }} is empty.</param>
            /// <exception cref="global::System.Exception">Any exception thrown from a delegate is rethrown.</exception>
            public void Visit({{ action_params }}, global::System.Action _)
            {
                switch (_n)
                {
                    case 0:
                        _();
                        break;
                    {{~ for $p in Params ~}}
                    case {{ $p.Index }}:
                        {{ $p.Hint }}({{ $storage $p }});
                        break;
                    {{~ end ~}}
                    default:
                        {{ throw_internal_error }};
                        break;
                }
            }

            {{~ ## UNION Visit(Action) ## ~}}
            /// <summary>
            /// Invoke the delegate whose parameter type matches that of the value stored within {{ Variant.Name }},
            /// and throw an exception if {{ Variant.Name }} is empty.
            /// </summary>
            {{~ for $p in Params ~}}
            /// <param name="{{ $p.Hint }}">The delegate to invoke if the stored value is of type <see cref="{{ cref $p.Name }}"/>.</param>
            {{~ end ~}}
            /// <exception cref="global::System.InvalidOperationException">{{ Variant.Name }} is empty.</exception>
            /// <exception cref="global::System.Exception">Any exception thrown from a delegate is rethrown.</exception>
            public void Visit({{ action_params }})
            {
                switch (_n)
                {
                    case 0:
                        {{ throw_empty_error }};
                        break;
                    {{~ for $p in Params ~}}
                    case {{ $p.Index }}:
                        {{ $p.Hint }}({{ $storage $p }});
                        break;
                    {{~ end ~}}
                    default:
                        {{ throw_internal_error }};
                        break;
                }
            }

            {{~ ## UNION Visit(Func) ## ~}}
            /// <summary>
            /// Invoke the delegate whose parameter type matches that of type of the value stored within {{ Variant.Name }} and return the result,
            /// and invoke a special delegate if {{ Variant.Name }} is empty and return its result.
            /// </summary>
            {{~ for $p in Params ~}}
            /// <param name="{{ $p.Hint }}">The delegate to invoke if the stored value is of type <see cref="{{ cref $p.Name }}"/>.</param>
            {{~ end ~}}
            /// <param name="_">The delegate to invoke if {{ Variant.Name }} is empty.</param>
            /// <exception cref="global::System.Exception">Any exception thrown from a delegate is rethrown.</exception>
            /// <typeparam name="TResult">The return type of all delegates, and by extension the return type of this function.</typeparam>
            public TResult Visit<TResult>({{ func_params }}, global::System.Func<TResult> _)
            {
                switch (_n)
                {
                    case 0:
                        return _();
                    {{~ for $p in Params ~}}
                    case {{ $p.Index }}:
                        return {{ $p.Hint }}({{ $storage $p }});
                    {{~ end ~}}
                    default:
                        return {{ throw_internal_error "TResult" }};
                }
            }

            {{~ ## UNION Visit(Func) ## ~}}
            /// <summary>
            /// Invoke the delegate whose parameter type matches that of the value stored within {{ Variant.Name }} and return the result,
            /// and throw an exception if {{ Variant.Name }} is empty.
            /// </summary>
            {{~ for $p in Params ~}}
            /// <param name="{{ $p.Hint }}">The delegate to invoke if the stored value is of type <see cref="{{ cref $p.Name }}"/>.</param>
            {{~ end ~}}
            /// <exception cref="global::System.InvalidOperationException">{{ Variant.Name }} is empty.</exception>
            /// <exception cref="global::System.Exception">Any exception thrown from a delegate is rethrown.</exception>
            /// <typeparam name="TResult">The return type of all delegates, and by extension the return type of this function.</typeparam>
            public TResult Visit<TResult>({{ func_params }})
            {
                switch (_n)
                {
                    case 0:
                        return {{ throw_empty_error "TResult" }};
                    {{~ for $p in Params ~}}
                    case {{ $p.Index }}:
                        return {{ $p.Hint }}({{ $storage $p }});
                    {{~ end ~}}
                    default:
                        return {{ throw_internal_error "TResult" }};
                }
            }
        }
    }
{{~ if Variant.Namespace ~}}
}
{{~ end ~}}
